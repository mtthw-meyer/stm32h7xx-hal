//! Power Configuration
//!
//! This module configures the PWR unit to provide the core voltage
//! `VCORE`. The voltage scaling mode is fixed at VOS1 (High
//! Performance).
//!
//! # Example
//!
//! ```rust
//!     let dp = pac::Peripherals::take().unwrap();
//!
//!     let pwr = dp.PWR.constrain();
//!     let vos = pwr.freeze();
//!
//!     assert_eq!(vos, VoltageScale::Scale1);
//! ```
//!
//! # SMPS
//!
//! Some parts include an integrated Switched Mode Power Supply (SMPS)
//! to supply VCORE. For these parts, the method of supplying VCORE
//! can be specified. Refer to RM0399 Rev 2 Table 31. for the possible
//! modes.
//!
//! These methods are always `unsafe`, because specifying the wrong
//! mode for your hardware will cut the power to the core.
//!
//! ```rust
//!     let dp = pac::Peripherals::take().unwrap();
//!
//!     let pwr = dp.PWR.constrain();
//!     let vos = unsafe {
//!         pwr.smps().freeze();
//!     }
//!
//!     assert_eq!(vos, VoltageScale::Scale1);
//! ```

use crate::stm32::PWR;

/// Extension trait that constrains the `PWR` peripheral
pub trait PwrExt {
    fn constrain(self) -> Pwr;
}

impl PwrExt for PWR {
    fn constrain(self) -> Pwr {
        Pwr {
            rb: self,
            #[cfg(any(feature = "dualcore"))]
            supply_configuration: SupplyConfiguration::Default,
        }
    }
}

/// Constrained PWR peripheral
///
/// Generated by calling `constrain` on the PAC's PWR peripheral.
pub struct Pwr {
    pub(crate) rb: PWR,
    #[cfg(any(feature = "dualcore"))]
    supply_configuration: SupplyConfiguration,
}

/// Voltage Scale
///
/// Generated when the PWR peripheral is frozen. The existence of this
/// value indicates that the voltage scaling configuration can no
/// longer be changed.
pub enum VoltageScale {
    Scale0,
    Scale1,
    Scale2,
    Scale3,
}

/// SMPS Supply Configuration - Dual Core parts
///
/// Refer to RM0399 Rev 2 Table 31.
#[cfg(any(feature = "dualcore"))]
enum SupplyConfiguration {
    Default = 0,
    LDOSupply,
    DirectSMPS,
    SMPSFeedsIntoLDO1V8,
    SMPSFeedsIntoLDO2V5,
    // External SMPS loads not supported
    Bypass,
}

#[cfg(any(feature = "dualcore"))]
macro_rules! supply_configuration_setter {
    ($($config:ident: $name:ident, $doc:expr,)*) => {
        $(
            #[doc=$doc]
            pub unsafe fn $name(mut self) -> Self {
                self.supply_configuration = SupplyConfiguration::$config;
                self
            }
        )*
    };
}

impl Pwr {
    #[cfg(any(feature = "dualcore"))]
    supply_configuration_setter! {
        LDOSupply: ldo, "VCORE power domains supplied from the LDO. \
                         LDO voltage adjusted by VOS. \
                         LDO power mode will follow the system \
                         low-power mode.",
        DirectSMPS: smps, "VCORE power domains are supplied from the \
                           SMPS step-down converter. SMPS output voltage \
                           adjusted by VOS. SMPS power mode will follow \
                           the system low-power mode",
        Bypass: bypass, "VCORE is supplied from an external source",
        SMPSFeedsIntoLDO1V8:
        smps_1v8_feeds_ldo, "VCORE power domains supplied from the LDO. \
                         LDO voltage adjusted by VOS. \
                         LDO power mode will follow the system \
                         low-power mode. SMPS output voltage set to \
                         1.8V. SMPS power mode will follow \
                         the system low-power mode",
        SMPSFeedsIntoLDO2V5:
        smps_2v5_feeds_ldo, "VCORE power domains supplied from the LDO. \
                         LDO voltage adjusted by VOS. \
                         LDO power mode will follow the system \
                         low-power mode. SMPS output voltage set to \
                         2.5V. SMPS power mode will follow \
                         the system low-power mode",
    }

    pub fn freeze(self) -> VoltageScale {
        // NB. The lower bytes of CR3 can only be written once after
        // POR, and must be written with a valid combination. Refer to
        // RM0433 Rev 6 5.8.4. This is enforced by dropping `self` at
        // the end of this method.

        #[cfg(any(feature = "singlecore"))]
        self.rb.cr3.modify(|_, w| {
            w.scuen().set_bit().ldoen().set_bit().bypass().clear_bit()
        });

        #[cfg(any(feature = "dualcore"))]
        self.rb.cr3.modify(|_, w| {
            use SupplyConfiguration::*;

            match self.supply_configuration {
                LDOSupply => w.sden().clear_bit().ldoen().set_bit(),
                DirectSMPS => w.sden().set_bit().ldoen().clear_bit(),
                SMPSFeedsIntoLDO1V8 => unsafe {
                    w.sden().set_bit().ldoen().set_bit().sdlevel().bits(1)
                },
                SMPSFeedsIntoLDO2V5 => unsafe {
                    w.sden().set_bit().ldoen().set_bit().sdlevel().bits(2)
                },
                Bypass => {
                    w.sden().clear_bit().ldoen().clear_bit().bypass().set_bit()
                }
                _ => {
                    // Default configuration
                    w.sden().set_bit().ldoen().set_bit()
                }
            }
        });

        // validate the supply configuration
        while self.rb.csr1.read().actvosrdy().bit_is_clear() {}

        // go to VOS1 voltage scale for high performance
        self.rb.d3cr.write(|w| unsafe { w.vos().bits(0b11) });
        while self.rb.d3cr.read().vosrdy().bit_is_clear() {}

        VoltageScale::Scale1
    }
}
