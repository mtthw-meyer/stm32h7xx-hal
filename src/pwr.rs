use crate::stm32::PWR;

/// Extension trait that constrains the `PWR` peripheral
pub trait PwrExt {
    fn constrain(self) -> Pwr;
}

impl PwrExt for PWR {
    fn constrain(self) -> Pwr {
        Pwr { rb: self }
    }
}

/// Constrained PWR peripheral
///
/// Generated by calling `constrain` on the PAC's PWR peripheral.
pub struct Pwr {
    pub(crate) rb: PWR,
}

/// Voltage Scale
///
/// Generated when the PWR peripheral is frozen. The existence of this
/// value indicates that the voltage scaling configuration can no
/// longer be changed.
pub enum VoltageScale {
    Scale0,
    Scale1,
    Scale2,
    Scale3,
}

impl Pwr {
    pub fn freeze(self) -> VoltageScale {
        #[cfg(any(feature = "singlecore"))]
        self.rb.cr3.write(|w| {
            w.scuen().set_bit().ldoen().set_bit().bypass().clear_bit()
        });

        #[cfg(any(feature = "dualcore"))]
        self.rb.cr3.modify(|_, w| {
            w.sden().set_bit().ldoen().clear_bit() // SMPS
        });

        // go to VOS1 voltage scale for high performance
        while self.rb.csr1.read().actvosrdy().bit_is_clear() {}
        self.rb.d3cr.write(|w| unsafe { w.vos().bits(0b11) });
        while self.rb.d3cr.read().vosrdy().bit_is_clear() {}

        VoltageScale::Scale1
    }
}
